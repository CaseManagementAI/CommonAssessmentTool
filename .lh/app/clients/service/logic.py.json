{
    "sourceFile": "app/clients/service/logic.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1730875940736,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1730875940736,
            "name": "Commit-0",
            "content": "import os\nfrom typing import List\nimport pandas as pd\nimport json\nimport numpy as np\nimport pickle\nfrom itertools import combinations_with_replacement\nfrom itertools import product\n\ncolumn_intervention = [\n    'Life Stabilization',\n    'General Employment Assistance Services',\n    'Retention Services',\n    'Specialized Services',\n    'Employment-Related Financial Supports for Job Seekers and Employers',\n    'Employer Financial Supports',\n    'Enhanced Referrals for Skills Development'\n]\n\n# loads the model into logic\n\n\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\nfilename = os.path.join(current_dir, 'model.pkl')\nmodel = pickle.load(open(filename, \"rb\"))\n\n\ndef clean_input_data(data):\n    # translate input into wahtever we trained the model on, numerical data in a specific order\n    columns = [\"age\", \"gender\", \"work_experience\", \"canada_workex\", \"dep_num\",\t\"canada_born\",\n               \"citizen_status\",\t\"level_of_schooling\",\t\"fluent_english\",\t\"reading_english_scale\",\n               \"speaking_english_scale\",\t\"writing_english_scale\",\t\"numeracy_scale\",\t\"computer_scale\",\n               \"transportation_bool\",\t\"caregiver_bool\",\t\"housing\",\t\"income_source\",\t\"felony_bool\",\t\"attending_school\",\n               \"currently_employed\",\t\"substance_use\",\t\"time_unemployed\",\t\"need_mental_health_support_bool\"]\n    demographics = {\n        'age': data['age'],\n        'gender': data['gender'],\n        'work_experience': data['work_experience'],\n        'canada_workex': data['canada_workex'],\n        'dep_num': data['dep_num'],\n        'canada_born': data['canada_born'],\n        'citizen_status': data['citizen_status'],\n        'level_of_schooling': data['level_of_schooling'],\n        'fluent_english': data['fluent_english'],\n        'reading_english_scale': data['reading_english_scale'],\n        'speaking_english_scale': data['speaking_english_scale'],\n        'writing_english_scale': data['writing_english_scale'],\n        'numeracy_scale': data['numeracy_scale'],\n        'computer_scale': data['computer_scale'],\n        'transportation_bool': data['transportation_bool'],\n        'caregiver_bool': data['caregiver_bool'],\n        'housing': data['housing'],\n        'income_source': data['income_source'],\n        'felony_bool': data['felony_bool'],\n        'attending_school': data['attending_school'],\n        'currently_employed': data['currently_employed'],\n        'substance_use': data['substance_use'],\n        'time_unemployed': data['time_unemployed'],\n        'need_mental_health_support_bool': data['need_mental_health_support_bool']\n    }\n    output = []\n    for column in columns:\n        # default is None, and if you want to pass a value, can return any value\n        data = demographics.get(column, None)\n        if isinstance(data, str):\n            data = convert_text(column, data)\n        output.append(data)\n    return output\n\n\ndef convert_text(column, data: str):\n    # Convert text answers from front end into digits\n    # TODO: ensure that categorical columns match the valid answers in FormNew.jsx (L131)\n    categorical_cols_integers = [\n        {\n            \"\": 0,\n            \"true\": 1,\n            \"false\": 0,\n            \"no\": 0,\n            \"yes\": 1,\n            \"No\": 0,\n            \"Yes\": 1\n        },\n        {\n            'Grade 0-8': 1,\n            'Grade 9': 2,\n            'Grade 10': 3,\n            'Grade 11': 4,\n            'Grade 12 or equivalent': 5,\n            'OAC or Grade 13': 6,\n            'Some college': 7,\n            'Some university': 8,\n            'Some apprenticeship': 9,\n            'Certificate of Apprenticeship': 10,\n            'Journeyperson': 11,\n            'Certificate/Diploma': 12,\n            'Bachelorâ€™s degree': 13,\n            'Post graduate': 14\n        },\n        {\n            'Renting-private': 1,\n            'Renting-subsidized': 2,\n            'Boarding or lodging': 3,\n            'Homeowner': 4,\n            'Living with family/friend': 5,\n            'Institution': 6,\n            'Temporary second residence': 7,\n            'Band-owned home': 8,\n            'Homeless or transient': 9,\n            'Emergency hostel': 10\n        },\n        {\n            'No Source of Income': 1,\n            'Employment Insurance': 2,\n            'Workplace Safety and Insurance Board': 3,\n            'Ontario Works applied or receiving': 4,\n            'Ontario Disability Support Program applied or receiving': 5,\n            'Dependent of someone receiving OW or ODSP': 6,\n            'Crown Ward': 7,\n            'Employment': 8,\n            'Self-Employment': 9,\n            'Other (specify)': 10\n        }\n    ]\n    for category in categorical_cols_integers:\n        print(f\"data: {data}\")\n        print(f\"column: {column}\")\n        if data in category:\n            return category[data]\n\n    if isinstance(data, str) and data.isnumeric():\n        return int(data)\n\n    return data\n\n# creates 128 possible combinations in order to run every possibility through model\n\n\ndef create_matrix(row):\n    data = [row.copy() for _ in range(128)]\n    perms = intervention_permutations(7)\n    data = np.array(data)\n    perms = np.array(perms)\n    matrix = np.concatenate((data, perms), axis=1)\n    return np.array(matrix)\n# create matrix of permutations of 1 and 0 of num length\n\n\ndef intervention_permutations(num):\n    perms = list(product([0, 1], repeat=num))\n    return np.array(perms)\n\n\ndef get_baseline_row(row):\n    print(type(row))\n    base_interventions = np.array([0]*7)  # no interventions\n    row = np.array(row)\n    print(row)\n    print(type(row))\n    line = np.concatenate((row, base_interventions))\n    return line\n\n\ndef intervention_row_to_names(row):\n    names = []\n    for i, value in enumerate(row):\n        if value == 1:\n            names.append(column_intervention[i])\n    return names\n\n\ndef process_results(baseline, results):\n    # Example:\n    \"\"\"\n    {\n        baseline_probability: 80 #baseline percentage point with no interventions\n        results: [\n            (85, [A,B,C]) #new percentange with intervention combinations and list of intervention names\n            (89, [B,C])\n            (91, [D,E])\n        ]\n    }\n    \"\"\"\n    result_list = []\n    for row in results:\n        percent = row[-1]\n        names = intervention_row_to_names(row)\n        result_list.append((percent, names))\n\n    output = {\n        # if it's an array, want the value inside of the array\n        \"baseline\": baseline[-1],\n        \"interventions\": result_list,\n    }\n    return output\n\n\ndef interpret_and_calculate(data):\n    raw_data = clean_input_data(data)\n    baseline_row = get_baseline_row(raw_data)\n    baseline_row = baseline_row.reshape(1, -1)\n    print(\"BASELINE ROW IS\", baseline_row)\n    intervention_rows = create_matrix(raw_data)\n    baseline_prediction = model.predict(baseline_row)\n    intervention_predictions = model.predict(intervention_rows)\n    # want shape to be a vertical column, not a row\n    intervention_predictions = intervention_predictions.reshape(-1, 1)\n    result_matrix = np.concatenate(\n        (intervention_rows, intervention_predictions), axis=1)  # CHANGED AXIS\n\n    # sort this matrix based on prediction\n    # print(\"RESULT SAMPLE::\", result_matrix[:5])\n    # take all rows and only last column, gives back list of indexes sorted\n    result_order = result_matrix[:, -1].argsort()\n    # indexing the matrix by the order\n    result_matrix = result_matrix[result_order]\n\n    # slice matrix to only top N results\n    # -8 for interventions and prediction, want top 3, 3 combinations of intervention\n    result_matrix = result_matrix[-3:, -8:]\n    # post process results if needed ie make list of names for each row\n    results = process_results(baseline_prediction, result_matrix)\n    # build output dict\n    print(f\"RESULTS: {results}\")\n    return results\n\n\nif __name__ == \"__main__\":\n    print(\"running\")\n    data = {\n        \"age\": \"23\",\n        \"gender\": \"1\",\n        \"work_experience\": \"1\",\n        \"canada_workex\": \"1\",\n        \"dep_num\": \"0\",\n        \"canada_born\": \"1\",\n        \"citizen_status\": \"2\",\n        \"level_of_schooling\": \"2\",\n        \"fluent_english\": \"3\",\n        \"reading_english_scale\": \"2\",\n        \"speaking_english_scale\": \"2\",\n        \"writing_english_scale\": \"3\",\n        \"numeracy_scale\": \"2\",\n        \"computer_scale\": \"3\",\n        \"transportation_bool\": \"2\",\n        \"caregiver_bool\": \"1\",\n        \"housing\": \"1\",\n        \"income_source\": \"5\",\n        \"felony_bool\": \"1\",\n        \"attending_school\": \"0\",\n        \"currently_employed\": \"1\",\n        \"substance_use\": \"1\",\n        \"time_unemployed\": \"1\",\n        \"need_mental_health_support_bool\": \"1\"\n    }\n    # print(data)\n    results = interpret_and_calculate(data)\n    print(results)\n"
        }
    ]
}